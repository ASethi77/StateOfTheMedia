{"organizations": [], "uuid": "cb38edc12282d3a262dd7f141ef6030b5cc2b658", "thread": {"site_full": "mathematica.stackexchange.com", "main_image": "http://cdn.sstatic.net/Sites/mathematica/img/apple-touch-icon@2.png?v=1b98edea1597&a", "site_section": "http://stackexchange.com//feeds/questions", "section_title": "Hot Questions - Stack Exchange", "url": "http://mathematica.stackexchange.com/questions/130984/why-and-when-does-pattern-matching-with-f-perform-much-more-quickly-than", "country": "US", "domain_rank": 179, "title": "Why (and when) does pattern matching with f[__] perform MUCH more quickly than _f? – mathematica.stackexchange.com", "performance_score": 0, "site": "stackexchange.com", "participants_count": 1, "title_full": "Why (and when) does pattern matching with f[__] perform MUCH more quickly than _f? – mathematica.stackexchange.com", "spam_score": 0.0, "site_type": "news", "published": "2016-11-13T13:21:00.000+02:00", "replies_count": 0, "uuid": "cb38edc12282d3a262dd7f141ef6030b5cc2b658"}, "author": "QuantumDot", "url": "http://mathematica.stackexchange.com/questions/130984/why-and-when-does-pattern-matching-with-f-perform-much-more-quickly-than", "ord_in_thread": 0, "title": "Why (and when) does pattern matching with f[__] perform MUCH more quickly than _f? – mathematica.stackexchange.com", "locations": [], "entities": {"persons": [], "locations": [], "organizations": [{"name": "wri", "sentiment": "none"}, {"name": "times", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "Using rest_ _myF _myG :> rest combinedForm improves noticeably the performance. The approach with myF[__] myG[__] will still scale better, as can be seen from a plot with those two patterns. – xavier 5 hours ago up vote 1 down vote \nTimes has the attributes Flat and Orderless . This means that any pattern that matches some combination of the arguments must, in principle, scan every permutation of arguments. Sometimes, the pattern matcher can optimize and avoid a full scan in the presence of explicit values and heads. Patterns of the form f[__] (i.e. f[BlankSequence[]] trigger such explicit head optimization whereas patterns like _f (i.e. Blank[f] ) do not -- presumably due to implementation details within the pattern matcher. \nAnalysis (current as of version 11.0.1) \nWe can reproduce the behaviour in a Flat Orderless function of our own devising: SetAttributes[times, {Flat, Orderless}] times[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f[1], g[2]] /. times[_f, _g] :> fg // AbsoluteTiming // First (* 7.62321 *) times[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f[1], g[2]] /. times[f[_], g[_]] :> fg // AbsoluteTiming // First (* 0.000033407 *) \nFlat Orderless Matching: The General Case \nLet us begin by examining the complexity of the general case when performing pattern matching upon a Flat Orderless function. Consider the following transformation: times[1, 2, 3, a] /. times[x_, a] :> {x, a} (* {times[1,2,3], a} *) \nTake note that the pattern matcher correctly identified that x matches multiple arguments to times , namely the leading prefix times[1, 2, 3] . We can observe the internal matching operation if we add conditions to the subpatterns that display some output: times[1, 2, 3, a] /. times[x_ /; (Echo[x, \"x_\"]; True), m_ /; (Echo[m, \"m_\"]; m===a)] :> {x, a} \nNotice how hard the pattern matcher had to work to get the final result. It had to scan through various permutations of subparts within the times[...] expression until it finally found its match. \nHelper Function \nWe will introduce a helper function tp that adjusts a pattern to display some output whenever it is matched: tp[patt_] := Module[{s}, Condition @@ Hold[s : patt, (Echo[{s}, patt]; True)]] \nThe Case At Hand \nWe can use this function to observe how pattern matcher operations grow exponentially as expression size increases for the problematic case at hand: times[1, 2, f[1], g[2]] /. times[tp[_f], tp[_g]] :> fg; times[1, 2, 3, f[1], g[2]] /. times[tp[_f], tp[_g]] :> fg; times[1, 2, 3, 4, f[1], g[2]] /. times[tp[_f], tp[_g]] :> fg; \nIn contrast, when we match using f[_] and g[_] instead of _f and _g , the number of operations remains constant: times[1, 2, f[1], g[2]] /. times[tp[f[_]], tp[g[_]]] :> fg; times[1, 2, 3, f[1], g[2]] /. times[tp[f[_]], tp[g[_]]] :> fg; times[1, 2, 3, 4, f[1], g[2]] /. times[tp[f[_]], tp[g[_]]] :> fg; \nClearly in the latter case the pattern matcher is applying an optimization. It need only scan the expression linearly to find the explicit heads f and g and then back-track to verify that the entire pattern is matched. We can see this explicitly if we also display the matched prefix: times[1, 2, 3, 4, f[1], g[2]] /. times[tp[___], tp[f[_]], tp[g[_]]] :> fg; \nEven a small case of the problematic expression will produce a lot of output if we trace the prefixes successively considered during its scan: times[1, 2, 3, f[1], g[2]] /. times[tp[___], tp[_f], tp[_g]] :> fg; \nNote that the matcher is considering numerous combinations until it finally finds the match. In fact, the output resembles the general case that we examined earlier although more rescanning is taking place here. \nThe pattern matcher is not recognizing that it has the same opportunity to optimize that it had in the previous expression. Apparently, its implementation will recognize that the pattern f[__] (i.e. f[BlankSequence[]] has an explicit head but it fails to make that recognition for _f (i.e. Blank[f] ). My guess is that this is an implementation coincidence and that the code is explicitly looking for the (meta)pattern _[BlankSequence[]] but not Blank[_] . The pattern matcher is rumoured to be an interesting piece of code so it might not necessarily be easy for WRI to introduce or maintain optimizations of this sort. \nDisclaimer \nBeware that it is difficult to trace the operation of the pattern matcher from high-level code. Any change to a pattern can alter the execution strategy chosen by the matcher (e.g. a change such as the trick used here of introducing a condition to display output). The examples shown in this response are meant to illustrate the principles involved rather than offering a strict step-by-step description of pattern matching operation.", "external_links": [], "published": "2016-11-13T13:21:00.000+02:00", "crawled": "2016-11-13T08:32:55.120+02:00", "highlightTitle": "", "social": {"gplus": {"shares": 0}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 0}, "facebook": {"likes": 0, "shares": 0, "comments": 0}, "stumbledupon": {"shares": 0}}}